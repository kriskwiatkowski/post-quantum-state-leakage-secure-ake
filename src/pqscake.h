#ifndef LIB_H_
#define LIB_H_

#include <stdint.h>
#include <stddef.h>
#include <pqc/pqc.h>
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SEED_SZ 32U
#define IDENT_LEN 16

/**
 * \brief Parameters of the KEM and signature scheme
 *
 * Both - static and ephemeral KEMs always use same
 * scheme.
 */
typedef struct params_t {
	//! Algorithm name as concatenation of KEM and signature scheme
	const char* alg_name;
	//! ID of the signature scheme
	const uint8_t sig_id;
	//! ID of the KEM scheme
	const uint8_t kem_id;

	//! Public key size of the signature scheme
	size_t sig_pub_sz;
	//! Private key size of the signature scheme
	size_t sig_prv_sz;
	//! Signature size of the signature scheme (upper bound)
	size_t sig_sz;

	//! Public key size of the KEM scheme
	size_t kem_pub_sz;
	//! Private key size of the KEM scheme
	size_t kem_prv_sz;
	//! KEM's shared secret size
	size_t kem_ss_sz;
	//! KEM's ciphertext size
	size_t kem_ct_sz;

	//! Byte size of the SID prefix (P_i||P_j||lpk_i||lpk_j)
	size_t sid_pfx_sz;
	//! Whole size of the SID
	size_t sid_sz;

	//! Security level of both KEM and signature scheme
	uint8_t nist_level;
} params_t;

/**
 * \brief Stores public and secret PQ key.
 */
typedef struct keypair_t {
	//! Buffer with public key
	buf_t pub_key;
	//! Buffer with secret key
	buf_t prv_key;
} keypair_t;

/**
 * \brief Data of single communication peer.
 */
typedef struct part_t {
	//! Index of the SIG+KEM pair from the algs array
	uint8_t alg_id;
	//! Either initiator or responder
	uint8_t role;

	//! Identifier of communicator peer (P_i or P_j)
	uint8_t ident[IDENT_LEN];
	//! Key pair of the signature
	keypair_t sig_keypair;
	//! Static (long-term) KEM key pair
	keypair_t kem_keypair_static;
	//! Private part of KEM ephemeral key (ek_T)
	buf_t kem_eph_prv_key;
} part_t;

/**
 * \brief Working buffers.
 *
 * Buffers of variable sizes, to store temporary
 * data during protocol execution.
 */
typedef struct workspace_t {
	buf_t sid;
	buf_t ss_st;
	buf_t ss_eph;
} workspace_t;

/**
 * \brief Session context
 *
 * Used to store session data.
 */
typedef struct comm_ctx_t {
	//! Parameters of a schemes used by session.
	const params_t *params;
	//! Signature operation context
	const pqc_ctx_t *sig_ctx;
	//! KEM operation context
	const pqc_ctx_t *kem_ctx;
	//!
	uint8_t seed[SEED_SZ];
	//! Prefix of a SID (P_i||P_j||lpk_i||lpk_j)
	buf_t sid_pfx;

	//! Data generated by the initiator
	struct {
		//! KEM long-term key used for K calculation
		buf_t kem_static;
		//! KEM ephemeral key used for K_T calculation
		buf_t kem_eph;
		//! Signature key vk_A
		buf_t sig;
		//! Pre-key signature. Signature of ephemeral key
		buf_t sign_A;
	} i;

	//! Data generated by the responder (party willing
	//  to communicate with the initiator).
	struct {
		//! Responder's public key
		buf_t pub_key_eph;
		//! Ciphertext from resulting from static key (KEM)
		buf_t ct_st;
		//! Ciphertext resulting from ephemeral key (wKEM)
		buf_t ct_eph;
		//! sign XOR k-hat
		buf_t sign;
	} r;
	//! Working buffers
	workspace_t w;
} comm_ctx_t;

// Defines a party in the protocol
enum {
	kInit, // Identifies initiator
	kResp  // Identifies responder
};

// Initialize lib
void init_lib();
// Initiator offers it's ephemeral key share
bool offer(comm_ctx_t *c, /*const*/part_t *p);
// Responder accept the offer and generates it's part of the key share
bool accept(uint8_t *session_key, comm_ctx_t *c, const part_t *p);
// Initiator finalizes session key calculations
bool finalize(uint8_t *session_key, comm_ctx_t *c, const part_t *p);
// Initializes state of the communication party
bool init_party(struct part_t *p, uint8_t role, uint8_t alg_id);
// Initializes the session
void init_session(comm_ctx_t *c, part_t p[2]);
// Cleans the session
void clean_session(comm_ctx_t *c);
// Frees memory used by the party
void clean_party(part_t *p);
// Get session parameters for the algorithm i as defined in algs[] array
const params_t *get_alg_params(size_t i);
// Amount of bytes exchanged during initialization phase (long term signing and KEM key)
size_t get_received_init_data_len(const comm_ctx_t *c);
// Claimed security level as defined by NIST
size_t get_scheme_sec(const comm_ctx_t *c);
// Amount of bytes sent by initiator (received by reciver)
size_t get_i2s(const comm_ctx_t *c);
// Amount of bytes received by the receiver
size_t get_s2r(const comm_ctx_t *c);
// Amount of bytes sent by the receiver
size_t get_r2s(const comm_ctx_t *c);
// Amount of bytes received by initiator (sent by reciver)
size_t get_s2i(const comm_ctx_t *c);
// Amount of data statically stored at the server per single user
size_t get_static_data_size(const comm_ctx_t *c);
// Amount of used during session establishement per single user-to-user
size_t get_session_est_data_size(const comm_ctx_t *c);
#ifdef __cplusplus
}
#endif

#endif
